type User = {
  oneof: { a: 1 } | { b: 2 };
  name: string;
  age?: number;
  friends: User[];
  address: {
    street: string;
    main: { enabled: boolean };
  };
};

type SafeShallowShape<Type> = {
  [_ in keyof Type]?: unknown;
};

function isString(v: unknown): v is string {
  type Extends<A extends B, B> = A;
  if (typeof v === "string") {
    void 0 as unknown as Extends<string, typeof v>;
    return true;
  }
  return false;
}

// type ExtendsNever<T> = [T] extends [never] ? true : false;
/**
 * All the calls to an empty function get removed by the minifier
 * or the JIT compiler.
 */
function is_never(_: never) {}

// Think of monomorphising too.
const safeIsArray: (v: unknown) => v is unknown[] = Array.isArray;

/**
 * Makes sure that the argument `root` has all the required fields
 * of the required types to be assignable to `NestedUser`.
 *
 * Generated by X. Feel free to patch to unblock your flow,
 * but keep in mind that this function will be regenerated
 * based on the next run.
 *
 * For better performance in cases of checking values that are
 * often of a wrong type try putting the properties that are likely
 * to be of wrong type closer to the top of the type declaration
 * to allow the guard to fail faster.
 */
function isNestedUser(root: unknown): root is User {
  // Checking `root`.
  if (!(typeof root === "object" && root !== null)) {
    return false;
  }
  is_never(
    // @ts-expect-error: should not be `never`
    root
  );

  // SAFETY: It's safe to cast `object` to an object type with all optional `unknown` props.
  const {
    oneof,
    name,
    age,
    friends,
    address,
  }: SafeShallowShape<User> = root;

  // Checking `root.oneof`.
  if (!(isNestedUser_oneof_1(oneof) || isNestedUser_oneof_2(oneof))) {
    return false;
  }
  is_never(
    // @ts-expect-error: should not be `never`
    oneof
  );

  // Checking `root.name`.
  if (!(typeof name === "string")) {
    return false;
  }
  is_never(
    // @ts-expect-error: should not be `never`
    name
  );

  // Checking `root.age`.
  if (!(typeof age === "number" || age === undefined)) {
    return false;
  }
  is_never(
    // @ts-expect-error: should not be `never`
    age
  );

  // Checking `root.friends`.
  if (!(safeIsArray(friends) && friends.every(isNestedUser))) {
    return false;
  }
  is_never(
    // @ts-expect-error: should not be `never`
    friends
  );

  // Checking `root.address`.
  if (!(typeof address === "object" && address !== null)) {
    return false;
  }
  is_never(
    // @ts-expect-error: should not be `never`
    address
  );

  const { street, main }: SafeShallowShape<User["address"]> = address;

  if (!(typeof street === "string")) {
    return false;
  }
  is_never(
    // @ts-expect-error: should not be `never`
    street
  );

  // Checking `root.address.main`.
  if (!(typeof main === "object" && main !== null)) {
    return false;
  }
  // The pragma below makes sure that the narrowing logic above does not have bugs
  // that would lead to inferring a `never` type. The `never` type is assignable
  // to any other type in TypeScript thus the explicit check. In practice,
  // having a `never` type means that the type guard will reject valid input.
  // If you ended up here try regenerating the code first,
  // if this does fix the error below then there is likely a bug in the generator.
  // Feel free to modify the code to unblock yourself and file an issue!
  is_never(
    // @ts-expect-error: should not be `never`
    main
  );
  // Don't use `as` type case here, it's unsafe: can cast `{}` to any object.
  // Keep using the type derived from the `root` type to catch mismatches when
  // the type gets updated without regenerating the guard.
  const { enabled }: SafeShallowShape<User["address"]["main"]> = main;
  // Checking `root.address.main.enabled`.
  if (!(typeof enabled === "boolean")) {
    return false;
  }

  // Notice: the hover types in VS Code do not tell the full truth.
  // TypeScript cannot narrow the shapes types down eagerly.
  // But when used in a new object expression the types get infered
  // correctly anyways. This is (presumably) thanks to how the flow
  // analysis works by tracing each type's trail back through all the
  // narrowing expressions.
  if (age !== undefined) {
    // SAFETY: this assignment makes sure that all the checked types are
    // assignable to the target type.
    // NOTE: having no property acesses here allows esbuild to completely
    // remove the whole block.
    const _root_type_assertion: User = {
      oneof,
      name,
      age,
      friends,
      address: {
        street,
        main: { enabled },
      },
    };
  }

  return true;
}

/**
 * This type has been extracted from `NestedUser["oneof"]` to enable use in unions and lists.
 * If it'a a huge type parts of which are copied over and over and it makes the code
 * less readable, please try breaking the root type into named subtypes manually.
 */
type NestedUser_oneof_1 = { a: 1 };
function isNestedUser_oneof_1(
  _root: unknown
): _root is NestedUser_oneof_1 {
  // al the same
  return true;
}

type NestedUser_oneof_2 = { b: 2 };
function isNestedUser_oneof_2(
  _root: unknown
): _root is NestedUser_oneof_2 {
  // al the same
  return true;
}
